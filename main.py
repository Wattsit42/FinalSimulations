import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import pandas as pd
# To change from the Sun-Jupiter system to the Earth Moon you need to comment some stuff out and uncomment some stuff.
# 1) In calc_fi switch what is commented out so you have the selection you want.
# 2) In restrictedH switch what is commented so you have the selection you want.
# 3) To get the correct Lagrange points go to lines 210, 211 and select the one you want.
# 4) To get the forbidden regions to plot correctly go to lines 248,251 and select the one you want.
# 5) To select the simulation go to line 213 and select one of the cases listed after.
# 6) To get the correct location of m1 and m2 go to lines 243-246 and select what you want.
# 7) To change scaling go to lines 264-268.
# 8) For a plot of the inertial frame uncomment lines 261-265.
# 9) For the poincare sections uncomment lines 275-288 and enter the values of x and y you want the cut at.
# 10) For error plotting uncomment lines 290-296.
# 11) Do not uncomment data saving without changing the name of the save file, otherwise it will overwrite.
# 12) Gauss 4th order is included but is not used beyond looking at error in the report and as an exercise in class inheritance

def calc_fi(x0):
    mu1 = 0.9990463 # Sun Jupiter
    mu2 = 9.537e-4
    # mu1 = 0.98785 # Earth Moon
    # mu2 = 1.215e-2
    U = calc_U(x0, mu1, mu2)
    #return -2*U - x0[0]**2 - x0[1]**2
    return -2*U - (x0[0]+x0[3])**2 - (x0[1]-x0[2])**2

def calc_Lagrnage_Points(mu1,mu2):
    l1y = 0
    a1 = (mu2/(3*mu1))**(1/3)
    l1x = mu1 - a1 + a1**2/3 + a1**3/9 + 23*a1**4/81
    l2y = 0
    l2x = mu1 + a1 + a1**2/3 - a1**3/9 - 31*a1**4/81
    l3y = 0
    rat = mu2/mu1
    l3x = -mu2 - 1 + (7/12*rat)-7/12*(rat)**2 + 13223/20736*(rat)**3
    l4x = 1/2 - mu2
    l4y = np.sqrt(3)/2
    l5x = 1/2 - mu2
    l5y = -np.sqrt(3)/2
    return np.array([l1x,l2x,l3x,l4x,l5x]), np.array([l1y,l2y,l3y,l4y,l5y])

def calc_U(x0,mu1,mu2):
    r1 = np.sqrt((x0[2] + mu2)**2 + x0[3]**2)
    r2 = np.sqrt((x0[2] - mu1)**2 + x0[3]** 2)
    U = -mu1/r1 - mu2/r2 - 1/2*(x0[2]**2 + x0[3]**2)
    return U

def apply_rotation_matrix(x,t):
    M =np.array([[np.cos(t),-np.sin(t)],[np.sin(t),np.cos(t)]])
    return M @ x

def derotate(x,times):
    derotated = np.array([])
    for i in range(len(x)):
        derotx = apply_rotation_matrix(x[i],times[i])
        derotated = np.append(derotated,derotx)
    derotated = np.reshape(derotated, (int(len(derotated)/2),2))
    return derotated

def restrictedH(x):
    mu1 = 0.9990463 # Jupiter sun
    mu2 = 9.537e-4
    # mu1 = 0.98785  # Earth Moon
    # mu2 = 1.215e-2
    r1 = np.sqrt((x[2] + mu2)**2 + x[3]**2)
    r2 = np.sqrt((x[2] - mu1)**2 + x[3]**2)
    q1dot = x[0] + x[3]
    q2dot = x[1] - x[2]
    pxdot = -x[2] + x[1] - mu1 * (x[2] + mu2)/r1**3 - mu2*(x[2] - mu1)/r2**3 + x[2]
    pydot = -x[3] - x[0] - mu1 * x[3]/r1**3 - mu2 * x[3]/r2**3 + x[3]
    return np.array([pxdot,pydot,q1dot,q2dot])

def select_coords_y(x,xy,target_value):
    # We want to find the points where the y value switches from sign
    # If xy = 3 then we get y cut if xy = 2 then we get the x cut
    indexes = np.array([])
    for i in range(len(x)-1):
        if (x[i,xy]-target_value)*(x[i+1,xy]-target_value) < 0:
            indexes = np.append(indexes,[i,i+1])
    indexes = np.reshape(indexes, (int(len(indexes)/2),2))
    return indexes

def linear_interpolation(x,indexes,xy, target_value):
    # xy = 0 then x=0 cut xy = 1 then y=0 cut
    cut_values = np.array([])
    t = 0
    for i in range(len(indexes)):
        if xy == 0:
            x1 = x[int(indexes[i,0]),2]
            x2 = x[int(indexes[i,1]),2]
            t = (target_value-x1)/(x2-x1)
        elif xy == 1:
            y1 = x[int(indexes[i,0]),3]
            y2 = x[int(indexes[i,1]),3]
            t = (target_value-y1)/(y2-y1)
        cut_values = np.append(cut_values, evaluate(x[int(indexes[i,0])],x[int(indexes[i,1])],t))
    cut_values = np.reshape(cut_values, (int(len(cut_values)/4),4))
    return cut_values

def evaluate(x1,x2,t):
    return (x2-x1)*t + x1

def abs_error(fi):
    #takes the first integral array generated by the method and copies the initial value the correct value of the first
    #integral and finds the difference.
    fi0 = fi[0]
    fi0_array = np.full(len(fi), fi0)
    return np.abs(fi - fi0_array)

class ButcherTab:
    def __init__(self,A,b,c):
        self.A = A
        self.b = b
        self.c = c

class Gauss:
    def __init__(self, func, t_0, x_0, h, max_t, Butcher):
        self.func = func
        self.t_0 = t_0
        self.x_0 = x_0
        self.max = max_t
        self.h = h
        self.B = Butcher

    def integrate(self,maxit, eps=1e-14):
        xsarr = np.array([self.x_0])
        times = np.array(self.t_0)
        first_integrals = np.array(calc_fi(self.x_0))
        xn = self.x_0
        t_n = self.t_0
        while t_n+self.h <= self.max:
            xn1 = self.step(xn, maxit,eps)
            xsarr = np.append(xsarr, xn1)
            t_n += self.h
            times = np.append(times, t_n)
            xn = xn1
            first_integrals = np.append(first_integrals, calc_fi(xn))
        return xsarr, times, first_integrals

    def step(self,xn,maxit,eps):
        x1,x2,x3 = xn.copy(), xn.copy(), xn.copy()
        for m in range(maxit):
            z1,z2,z3 = x1.copy(), x2.copy(), x3.copy()
            x1 = self.func(xn + self.h*(self.B.A[0][0]*z1 + self.B.A[0][1]*z2 + self.B.A[0][2]*z3))
            x2 = self.func(xn + self.h*(self.B.A[1][0]*z1 + self.B.A[1][1]*z2 + self.B.A[1][2]*z3))
            x3 = self.func(xn + self.h*(self.B.A[2][0]*z1 + self.B.A[2][1]*z2 + self.B.A[2][2]*z3))
            if np.sum(abs(x1-z1)) + np.sum(abs(x2-z2)) + np.sum(abs(x3-z3)) <= eps:
                return xn + self.h * (self.B.b[0]*x1 + self.B.b[1]*x2 + self.B.b[2]*x3)
        raise

class Gauss4(Gauss):

    def step(self, xn, maxit, eps):
        x1, x2 = xn.copy(), xn.copy()
        for m in range(maxit):
            z1, z2 = x1.copy(), x2.copy()
            x1 = self.func(xn + self.h * (self.B.A[0][0] * z1 + self.B.A[0][1] * z2 ))
            x2 = self.func(xn + self.h * (self.B.A[1][0] * z1 + self.B.A[1][1] * z2 ))
            if np.sum(abs(x1 - z1)) + np.sum(abs(x2 - z2))  <= eps:
                return xn + self.h * (self.B.b[0] * x1 + self.B.b[1] * x2 )
        raise

class explicitRK:
    def __init__(self, func, t_0, x_0, h, max_t, Butcher):
        self.func = func
        self.t_0 = t_0
        self.x_0 = x_0
        self.max = max_t
        self.h = h
        self.B = Butcher

    def integrate(self):
        xsarr = np.array([self.x_0])
        times = np.array(self.t_0)
        first_integrals = np.array(calc_fi(self.x_0))
        xn = self.x_0
        t_n = self.t_0
        while t_n+self.h <= self.max:
            xn1 = self.step(xn)
            xsarr = np.append(xsarr, xn1)
            t_n += self.h
            times = np.append(times, t_n)
            xn = xn1
            first_integrals = np.append(first_integrals, calc_fi(xn))
        return  xsarr, times, first_integrals

    def step(self,xn):
        k_array = np.zeros([len(self.B.A),len(self.B.A)])
        for i in range(len(self.B.A)):
            ki = self.func(self.interior_staging(i,xn,k_array))
            k_array[i] = ki.copy()
        stages = self.B.b*k_array
        xn1 = xn + self.h * self.sum_of_stages(k_array)
        return xn1

    def sum_of_stages(self,stages):
        stage_sum = np.zeros(len(stages))
        for i in range(len(stages)):
            stage_sum += stages[i]*self.B.b[i]
        return stage_sum

    def interior_staging(self,i,xn,ks):
        stage_sum = np.zeros(len(ks))
        for j in range(len(self.B.A[i])):
            stage_sum += self.B.A[i][j]*ks[j]
        return xn + self.h*stage_sum

lx,ly = calc_Lagrnage_Points(0.9990463,9.537e-4) ##Sun Jupiter
#lx, ly = calc_Lagrnage_Points(0.98785,1.215e-2) # Earth Moon

#Included Simulations
x0 = np.array([0.0,1.1,0.6,0.0]) ## First Simulation Interior region
#x0 = np.array([0.0,0.9,0.9,0.0]) ## Second Simulation Periodic
#x0 = np.array([-1.51337587, -1.2256231, -0.18189379, 0.313927]) ## Third Simulation Return orbit, short term simulation
#x0 = np.array([-0.01, lx[2], lx[2], 0.01]) ## Fourth Simulation horseshoe
#x0 = np.array([-ly[0], lx[0] + 0.21, lx[0] + 0.01, ly[0]]) ## Fifth Jupiter orbit
#x0 = np.array([0.0,0.0,lx[3]+0.01,ly[3]]) # L4 stable orbit
#x0 = np.array([0.0,0.0,lx[4]+0.01,ly[4]]) # L5 stable orbit
#x0 = np.array([-ly[4],lx[4]+0.0221,lx[4]+0.0221,ly[4]]) # Nice periodic like behaviour around L5
#x0 = np.array([-ly[4],lx[4]+0.02294,lx[4]+0.02294,ly[4]]) # Drift into horseshoe orbit from L5 orbit

t0=0
h = 0.01
max_t = 5000

GO6 = ButcherTab([[5/36,2/9 - (np.sqrt(15))/15,5/36 - (np.sqrt(15))/30],[5/36+(np.sqrt(15))/24,2/9,5/36-np.sqrt(15)/24],[5/36+np.sqrt(15)/30,2/9+np.sqrt(15)/15,5/36]],[5/18,4/9,5/18],[1/2-np.sqrt(15)/10,1/2,1/2+np.sqrt(15)])
GO4 = ButcherTab([[1/4,1/4-np.sqrt(3)/6],[1/4+np.sqrt(3)/6,1/4]],[1/2,1/2],[1/2-np.sqrt(3)/6,1/2+np.sqrt(3)/6])
RK4 = ButcherTab([[0,0,0,0],[1/2,0,0,0],[0,1/2,0,0],[0,0,1,0]],[1/6,2/6,2/6,1/6],[0,1/2,1/2,1])
Gl6 = Gauss(restrictedH, t0, x0, h, max_t, GO6)
xn, times, fi = Gl6.integrate(20)
GL4 = Gauss4(restrictedH, t0, x0, h, max_t, GO4)
#xn,times, fi = GL4.integrate(20)
runge_kutta = explicitRK(restrictedH,t0,x0,h,max_t,RK4)
#xn1, times1, fi1 = runge_kutta.integrate()

xn = np.reshape(xn, (int(len(xn)/4),4))

C = calc_fi(x0)
f = lambda x, y : -2*(-0.9990463/np.sqrt((x+9.537e-4)**2 + y**2) - 9.537e-4/np.sqrt((x-0.9990463)**2 + y**2) - 1/2*(x**2 + y**2)) # Sun Jupiter
#f = lambda x, y : -2*(-0.98785/np.sqrt((x+1.215e-2)**2 + y**2) - 1.215e-2/np.sqrt((x-0.98785)**2 + y**2) - 1/2*(x**2 + y**2)) # Earth Moon
d = np.linspace(-2,2,2000)
x,y = np.meshgrid(d,d)
fig,ax = plt.subplots()
im = plt.imshow( (f(x,y) < C), extent=(x.min(), x.max(), y.min(), y.max()), origin='lower', cmap='Greys')

ax.scatter(0.9990463,0) # Sun Jupiter
ax.scatter(-9.537e-4,0)
# ax.scatter(0.98785,0) # Earth Moon
# ax.scatter(1.215e-2,0)
ax.plot(xn[:,2],xn[:,3],label='Rotating Orbit')
ax.scatter(lx,ly, marker='x',color='r')
plt.title("t=" + str(max_t/(2*np.pi))[:5] + " Jupiter Years")
plt.xlabel('x')
plt.ylabel('y')

plt.xlim(-1.5,1.5)
plt.ylim(-1.5,1.5)

for i in range(len(lx)):
    plt.text(lx[i] + 0.08,ly[i]+0.08, 'L'+ str(i+1), color='r')

#Inertial frame plot
# rotation_coords = np.column_stack((xn[:,2],xn[:,3]))
# derotated_coords = derotate(rotation_coords,times)
#plt.plot(derotated_coords[:,0],derotated_coords[:,1],label='Non-Rotating Orbit')
#ax.legend(loc='upper right')

plt.show()
## Poincare Section

ax.clear()

## want the y = a cut
# indexes = select_coords_y(xn,3,-0.9) # 3rd variable is where we take the y=a cut
# y0section = linear_interpolation(xn,indexes,1,-0.9) # Interpolates between points either side to find where we cross the surface
# plt.plot(y0section[:,0],y0section[:,2],'.')
# plt.xlabel('px')
# plt.ylabel('x')
# plt.show()
# # x = a cut
# indexes = select_coords_y(xn,2,0.5) # 3rd variable is where we take the x=a cut
# y0section = linear_interpolation(xn,indexes,0,0.5) # Interpolates between either side to find where we cross the surface
# plt.plot(y0section[:,1],y0section[:,3],'.')
# plt.xlabel('py')
# plt.ylabel('y')
# plt.show()
#
## Error plotting
# plt.plot(times, abs_error(fi), label='Gauss Error')
# plt.plot(times, abs_error(fi1), label='RK4 Error')
# plt.xlabel('t')
# plt.ylabel('Absolute error')
# plt.legend(loc='upper right')
# plt.show()
#
# print(-ly[3] + ly[3])

#Data saving
# xframe = pd.DataFrame(xn)
# tframe = pd.DataFrame(times)
# fiframe = pd.DataFrame(fi)
# fi1frame = pd.DataFrame(fi1)
# xframe.to_csv('First_Simulation_x.csv')
# tframe.to_csv('First_Simulation_t.csv')
# fiframe.to_csv('First_Simulation_fi.csv')
# fi1frame.to_csv('RK4_fi1.csv')