import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import pandas as pd

def calc_fi(x0):
    mu1 = 0.9990463
    mu2 = 9.537e-4
    #mu1 = 0.9
    #mu2 = 0.1
    #mu1 = 0.98785
    #mu2 = 1.215e-2
    U = calc_U(x0, mu1, mu2)
    #return -2*U - x0[0]**2 - x0[1]**2
    return -2*U - (x0[0]+x0[3])**2 - (x0[1]-x0[2])**2

def calc_Lagrnage_Points(mu1,mu2):
    l1y = 0
    a1 = (mu2/(3*mu1))**(1/3)
    l1x = mu1 - a1 + a1**2/3 + a1**3/9 + 23*a1**4/81
    l2y = 0
    l2x = mu1 + a1 + a1**2/3 - a1**3/9 - 31*a1**4/81
    l3y = 0
    rat = mu2/mu1
    l3x = -mu2 - 1 + (7/12*rat)-7/12*(rat)**2 + 13223/20736*(rat)**3
    l4x = 1/2 - mu2
    l4y = np.sqrt(3)/2
    l5x = 1/2 - mu2
    l5y = -np.sqrt(3)/2
    return np.array([l1x,l2x,l3x,l4x,l5x]), np.array([l1y,l2y,l3y,l4y,l5y])

def calc_U(x0,mu1,mu2):
    r1 = np.sqrt((x0[2] + mu2)**2 + x0[3]**2)
    r2 = np.sqrt((x0[2] - mu1)**2 + x0[3]** 2)
    U = -mu1/r1 - mu2/r2 - 1/2*(x0[2]**2 + x0[3]**2)
    return U

def apply_rotation_matrix(x,t):
    M =np.array([[np.cos(t),-np.sin(t)],[np.sin(t),np.cos(t)]])
    return M @ x

def derotate(x,times):
    derotated = np.array([])
    for i in range(len(x)):
        derotx = apply_rotation_matrix(x[i],times[i])
        derotated = np.append(derotated,derotx)
    derotated = np.reshape(derotated, (int(len(derotated)/2),2))
    return derotated

# def restricted(x):
#     # form of x is [px,py,q1,q2]
#     mu1 = 0.9990463
#     mu2 = 9.537e-4
#     #mu1 = 0.9
#     #mu2 = 0.1
#     #mu1 = 0.98785
#     #mu2 = 1.215e-2
#     r1 = np.sqrt((x[2] + mu2)**2 + x[3]**2)
#     r2 = np.sqrt((x[2] - mu1)**2 + x[3]**2)
#     q1dot = x[0]
#     q2dot = x[1]
#     pxdot = 2*x[1] - mu1 * (x[2] + mu2)/r1**3 - mu2*(x[2] - mu1)/r2**3 + x[2]
#     pydot = -2*x[0] - mu1 * x[3]/r1**3 - mu2 * x[3]/r2**3 + x[3]
#     return np.array([pxdot,pydot,q1dot,q2dot])

def restrictedH(x):
    mu1 = 0.9990463
    mu2 = 9.537e-4
    r1 = np.sqrt((x[2] + mu2)**2 + x[3]**2)
    r2 = np.sqrt((x[2] - mu1)**2 + x[3]**2)
    q1dot = x[0] + x[3]
    q2dot = x[1] - x[2]
    pxdot = -x[2] + x[1] - mu1 * (x[2] + mu2)/r1**3 - mu2*(x[2] - mu1)/r2**3 + x[2]
    pydot = -x[3] - x[0] - mu1 * x[3]/r1**3 - mu2 * x[3]/r2**3 + x[3]
    return np.array([pxdot,pydot,q1dot,q2dot])

def select_coords_y(x,xy,target_value):
    # We want to find the points where the y value switches from sign
    # If xy = 3 then we get y cut if xy = 2 then we get the x cut
    indexes = np.array([])
    for i in range(len(x)-1):
        if (x[i,xy]-target_value)*(x[i+1,xy]-target_value) < 0:
            indexes = np.append(indexes,[i,i+1])
    indexes = np.reshape(indexes, (int(len(indexes)/2),2))
    return indexes

def linear_interpolation(x,indexes,xy, target_value):
    # xy = 0 then x=0 cut xy = 1 then y=0 cut
    cut_values = np.array([])
    t = 0
    for i in range(len(indexes)):
        if xy == 0:
            x1 = x[int(indexes[i,0]),2]
            x2 = x[int(indexes[i,1]),2]
            t = (target_value-x1)/(x2-x1)
        elif xy == 1:
            y1 = x[int(indexes[i,0]),3]
            y2 = x[int(indexes[i,1]),3]
            t = (target_value-y1)/(y2-y1)
        cut_values = np.append(cut_values, evaluate(x[int(indexes[i,0])],x[int(indexes[i,1])],t))
    cut_values = np.reshape(cut_values, (int(len(cut_values)/4),4))
    return cut_values

def evaluate(x1,x2,t):
    return (x2-x1)*t + x1

def abs_error(fi):
    #takes the first integral array generated by the method and copies the initial value the correct value of the first
    #integral and finds the difference.
    fi0 = fi[0]
    fi0_array = np.full(len(fi), fi0)
    return np.abs(fi - fi0_array)

class ButcherTab:
    def __init__(self,A,b,c):
        self.A = A
        self.b = b
        self.c = c

class Gauss:
    def __init__(self, func, t_0, x_0, h, max_t, Butcher):
        self.func = func
        self.t_0 = t_0
        self.x_0 = x_0
        self.max = max_t
        self.h = h
        self.B = Butcher

    def integrate(self,maxit, eps=1e-14):
        xsarr = np.array([self.x_0])
        times = np.array(self.t_0)
        first_integrals = np.array(calc_fi(self.x_0))
        xn = self.x_0
        t_n = self.t_0
        while t_n+self.h <= self.max:
            xn1 = self.step(xn, maxit,eps)
            xsarr = np.append(xsarr, xn1)
            t_n += self.h
            times = np.append(times, t_n)
            xn = xn1
            first_integrals = np.append(first_integrals, calc_fi(xn))
        return xsarr, times, first_integrals

    def step(self,xn,maxit,eps):
        x1,x2,x3 = xn.copy(), xn.copy(), xn.copy()
        for m in range(maxit):
            z1,z2,z3 = x1.copy(), x2.copy(), x3.copy()
            x1 = self.func(xn + self.h*(self.B.A[0][0]*z1 + self.B.A[0][1]*z2 + self.B.A[0][2]*z3))
            x2 = self.func(xn + self.h*(self.B.A[1][0]*z1 + self.B.A[1][1]*z2 + self.B.A[1][2]*z3))
            x3 = self.func(xn + self.h*(self.B.A[2][0]*z1 + self.B.A[2][1]*z2 + self.B.A[2][2]*z3))
            if np.sum(abs(x1-z1)) + np.sum(abs(x2-z2)) + np.sum(abs(x3-z3)) <= eps:
                return xn + self.h * (self.B.b[0]*x1 + self.B.b[1]*x2 + self.B.b[2]*x3)
        raise

class explicitRK:
    def __init__(self, func, t_0, x_0, h, max_t, Butcher):
        self.func = func
        self.t_0 = t_0
        self.x_0 = x_0
        self.max = max_t
        self.h = h
        self.B = Butcher

    def integrate(self):
        xsarr = np.array([self.x_0])
        times = np.array(self.t_0)
        first_integrals = np.array(calc_fi(self.x_0))
        xn = self.x_0
        t_n = self.t_0
        while t_n+self.h <= self.max:
            xn1 = self.step(xn)
            xsarr = np.append(xsarr, xn1)
            t_n += self.h
            times = np.append(times, t_n)
            xn = xn1
            first_integrals = np.append(first_integrals, calc_fi(xn))
        return xsarr, times, first_integrals

    def step(self,xn):
        k_array = np.zeros([len(self.B.A),len(self.B.A)])
        for i in range(len(self.B.A)):
            ki = self.func(self.interior_staging(i,xn,k_array))
            k_array[i] = ki.copy()
        stages = self.B.b*k_array
        xn1 = xn + self.h * self.sum_of_stages(k_array)
        return xn1

    def sum_of_stages(self,stages):
        stage_sum = np.zeros(len(stages))
        for i in range(len(stages)):
            stage_sum += stages[i]*self.B.b[i]
        return stage_sum

    def interior_staging(self,i,xn,ks):
        stage_sum = np.zeros(len(ks))
        for j in range(len(self.B.A[i])):
            stage_sum += self.B.A[i][j]*ks[j]
        return xn + self.h*stage_sum

lx,ly = calc_Lagrnage_Points(0.9990463,9.537e-4)


#velocity then coords
#x0 = np.array([0.0,0.0,0.97,0.0])
#x0 = np.array([0.0,0.0,0.5,0.5])
#lx, ly = calc_Lagrnage_Points(0.9,0.1)
#x0 = np.array([0.0,0.0,lx[4]+0.1,ly[4]])
#x0 = np.array([-1.7,-0.6,0.85,0.0])
#x0 = np.array([0.01,0.0,lx[3],ly[3]])
#x0 = np.array([0.0,0.0,lx[3]+0.01,ly[3]])
#x0 = np.array([0.0,0.5,0.6,0.0])
#x0 = np.array([0.0,0.0,lx[3],ly[3]])
#x0 = np.array([-0.275,0.01,0.98,0.0])
#x0 = np.array([0.0,0.9,1.0,0.0])
#x0 = np.array([0.0,0.15,0.8,0.0])
#x0 = np.array([-1.5,0.09,0.85,0.0])
#x0 = np.array([-1.8,0.3,0.85,0.0])
#x0 = np.array([-0.5,0.5,lx[0],ly[0]])
#x0 = np.array([0.0,0.2,lx[0]+0.01,ly[0]])

##Interior Region Plots

#x0 = np.array([0.0,0.0,lx[0]-0.1,0.0]) # 1
#x0 = np.array([0.0,0.05,lx[0]-0.1,0.0]) # 2
#x0 = np.array([0.0,0.5,0.5,0.0]) # 3
#x0 = np.array([0.5,1.5,0.2,0.0]) # 4 needed stepsize 0.001
#x0 = np.array([0.0,0.0,0.9,0.0]) # 5
#x0 = np.array([0.0,0.0,0.5,0.5]) # 6
#x0 = np.array([0.0,0.6,0.4,0.0]) # 7
#x0 = np.array([0.0,0.0,lx[3]-0.4,ly[3]]) # 8
#x0 = np.array([0.0,0.0,0.9,0.01])

#Transfer Regime

#x0 = np.array([0.0,0.0,lx[0],0.01]) # 1
#x0 = np.array([-0.01,0.02,lx[0],0.0]) # 2
#x0 = np.array([0.005,0.03,lx[0],0.0]) # 3

# Exit Regime

#x0 = np.array([0.0,0.0,lx[1],0.0])
#x0 = np.array([-0.12,0.01,lx[1],0.0])

# Low Restriction Regime
#x0 = np.array([0.0,0.0,lx[2]-0.01,0.0]) # 1
#x0 = np.array([0.0,0.0,lx[2],0.01]) # 2
#x0 = np.array([0.0,0.01,lx[2],0.0]) # 3
#x0 = np.array([0.01,0.0,lx[2],0.02]) # 4 same behaviour
#x0 = np.array([0.0,0.0,lx[3]+0.025,ly[3]]) # 5 Back and forth behaviour, yay!!!!

# Unrestricted

#x0 = np.array([-0.6,0.2,lx[0]+0.01,0.0]) # 1
#x0 = np.array([-0.5,0.3,0.9,0.0]) # 2
#x0 = np.array([0.0,0.2,lx[0]+0.01,ly[0]]) # 3
#x0 = np.array([0.0,2.1,0.3,0.0]) # 4
#x0 = np.array([0.3,0.0,lx[2]-0.1,0.0]) # 5
#x0 = np.array([0.5,0.4,lx[2]-0.3,0.0]) # 6

# Lagrange Points

#x0 = np.array([0.0,0.0,lx[3]+0.01,ly[3]])
#x0 = np.array([0.0,0.0,lx[4]+0.01,ly[4]])


# Reformulated in Hamiltonian Coords so the Symplectic method actually works
#x0 = np.array([-ly[3],lx[3],lx[3],ly[3]])
#x0 = np.array([-0.01,lx[2],lx[2],0.01]) #Low restriction case 2 adjusted
#x0 = np.array([-ly[0],0.21+lx[0],lx[0]+0.01,ly[0]]) # Orbit around Jupiter
#x0 = np.array([0.0,1.1,0.6,0.0])
x0 = np.array([-ly[4],lx[4]+0.01,lx[4]+0.01,ly[4]])


t0=0
h = 0.1
max_t = 50000

GO6 = ButcherTab([[5/36,2/9 - (np.sqrt(15))/15,5/36 - (np.sqrt(15))/30],[5/36+(np.sqrt(15))/24,2/9,5/36-np.sqrt(15)/24],[5/36+np.sqrt(15)/30,2/9+np.sqrt(15)/15,5/36]],[5/18,4/9,5/18],[1/2-np.sqrt(15)/10,1/2,1/2+np.sqrt(15)])
Gl = Gauss(restrictedH, t0, x0, h, max_t, GO6)
xn,times, fi = Gl.integrate(20)
RK4 = ButcherTab([[0,0,0,0],[1/2,0,0,0],[0,1/2,0,0],[0,0,1,0]],[1/6,2/6,2/6,1/6],[0,1/2,1/2,1])
runge_kutta = explicitRK(restrictedH,t0,x0,h,max_t,RK4)
xn1, times1, fi1 = runge_kutta.integrate()
xn = np.reshape(xn, (int(len(xn)/4),4))


C = calc_fi(x0)


f = lambda x, y : -2*(-0.9990463/np.sqrt((x+9.537e-4)**2 + y**2) - 9.537e-4/np.sqrt((x-0.9990463)**2 + y**2) - 1/2*(x**2 + y**2)) #-2U
#f = lambda x, y : -2*(-0.9/np.sqrt((x+0.1)**2 + y**2) - 0.1/np.sqrt((x-0.9)**2 + y**2) - 1/2*(x**2 + y**2)) #-2U
#f = lambda x, y : -2*(-0.98785/np.sqrt((x+1.215e-2)**2 + y**2) - 1.215e-2/np.sqrt((x-0.98785)**2 + y**2) - 1/2*(x**2 + y**2)) #-2U

d = np.linspace(-2,2,2000)
x,y = np.meshgrid(d,d)

fig,ax = plt.subplots()


im = plt.imshow( (f(x,y) < C), extent=(x.min(), x.max(), y.min(), y.max()), origin='lower', cmap='Greys')

ax.scatter(0.9990463,0)
ax.scatter(-9.537e-4,0)
#ax.scatter(0.98785,0)
#ax.scatter(1.215e-2,0)
#ax.scatter(0.9,0)
#ax.scatter(-0.1,0)
ax.plot(xn[:,2],xn[:,3],label='Rotating Orbit')
ax.scatter(lx,ly, marker='x',color='r')
#ax.scatter(0,0,marker = '+',color='black')
plt.title("t=" + str(max_t/(2*np.pi))[:5] + " Jupiter Years")
#plt.title("t=" + str(max_t))
plt.xlabel('x')
plt.ylabel('y')
#
# plt.xlim(-3,3)
# plt.ylim(-3,3)

#plt.xlim(-10,10)
#plt.ylim(-10,10)
#
# plt.xlim(-1.5,1.5)
# plt.ylim(-1.5,1.5)

# plt.xlim(-1.1,1.1)
# plt.ylim(-1.1,1.1)

#plt.xlim(-3,3)
#plt.ylim(-3,3)

# plt.xlim(-1,1.1)
# plt.ylim(-1,1)

# plt.xlim(0.0,1)
# plt.ylim(-1.5,-0.5)

# plt.xlim(0.2,0.7)
# plt.ylim(-0.25,0.25)

# plt.xlim(0.8,1.2)
# plt.ylim(-0.2,0.2)

# plt.ylim(-0.1,0.1)
# plt.xlim(0.9,1.1)

plt.xlim(0,0.8)
plt.ylim(-1.1,-0.5)


##For the L4,L5 orbits use this scaling
#plt.ylim(0.5,1.5)
#plt.xlim(0,1)
for i in range(len(lx)):
    plt.text(lx[i] + 0.08,ly[i]+0.08, 'L'+ str(i+1), color='r')

#Inertial frame plot

rotation_coords = np.column_stack((xn[:,2],xn[:,3]))
derotated_coords = derotate(rotation_coords,times)
#plt.plot(derotated_coords[:,0],derotated_coords[:,1],label='Non-Rotating Orbit')
ax.legend(loc='upper right')

plt.show()
ax.clear()
## Poincare Section

## want the y = a cut
indexes = select_coords_y(xn,3,-0.9)
y0section = linear_interpolation(xn,indexes,1,-0.9)
plt.plot(y0section[:,0],y0section[:,2],'.')
plt.xlabel('px')
plt.ylabel('x')
plt.show()
# x = a cut
indexes = select_coords_y(xn,2,0.5)
y0section = linear_interpolation(xn,indexes,0,0.5)
plt.plot(y0section[:,1],y0section[:,3],'.')
plt.xlabel('py')
plt.ylabel('y')
plt.show()

plt.plot(times, abs_error(fi), label='Gauss Error')
plt.plot(times, abs_error(fi1), label='RK4 Error')
plt.xlabel('t')
plt.ylabel('absolute error')
plt.legend(loc='upper right')
plt.show()

print(-ly[3] + ly[3])

xframe = pd.DataFrame(xn)
tframe = pd.DataFrame(times)
fiframe = pd.DataFrame(fi)
fi1frame = pd.DataFrame(fi1)
xframe.to_csv('L5stability_experiment_x.csv')
tframe.to_csv('L5stability_experiment_t.csv')
fiframe.to_csv('L5stability_experiment_Gauss_fi.csv')
fi1frame.to_csv('L5stability_experiment_rk4_fi.csv')